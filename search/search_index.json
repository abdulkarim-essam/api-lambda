{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Lambda Router","text":"<p>A lightweight, Flask-inspired routing framework for AWS Lambda functions with API Gateway integration. Build serverless APIs with clean, decorative routing and automatic request/response handling.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flask-style Decorative Routing - Clean <code>@route()</code> decorators for endpoint definition</li> <li>Simple Request/Response Handling - JSON parsing, CORS, error handling out of the box</li> <li>Dynamic Path Parameters - Support for both <code>{id}</code> and <code>&lt;id&gt;</code> parameter styles</li> <li>Zero Dependencies - Pure Python, no external packages required</li> <li>Type Safety - Full type hints and protocol definitions</li> <li>CORS Support - Built-in CORS handling for web applications</li> <li>Debug Mode - Detailed error tracebacks for development</li> <li>Customizable Errors - Custom error response factories</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install api-lambda-router\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>from api_lambda import route, api_handler, HTTPRequest\n\n@route(\"/hello\", methods=\"GET\")\ndef hello_world(request: HTTPRequest):\n    return {\"message\": \"Hello, World!\"}\n\n@route(\"/users/{user_id}\", methods=[\"GET\", \"PUT\"])\ndef handle_user(request: HTTPRequest):\n    user_id = request.path[\"user_id\"]\n\n    if request.body.get(\"name\"):\n        # PUT - Update user\n        return {\"user_id\": user_id, \"name\": request.body[\"name\"]}, 200\n    else:\n        # GET - Retrieve user\n        return {\"user_id\": user_id, \"name\": \"John Doe\"}\n\n# AWS Lambda handler\ndef lambda_handler(event, context):\n    return api_handler(event, context, cors_enabled=True, debug_mode=True)\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>This library is specifically designed for AWS Lambda + API Gateway:</p> <pre><code>Internet \u2192 API Gateway \u2192 Lambda Function \u2192 Your Routes\n</code></pre>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub: Issues &amp; Discussions</li> <li>Email: abdulkarim.essam@hotmail.com</li> </ul> <p>Made with \u2764\ufe0f for the serverless community</p>"},{"location":"api-reference/request/","title":"Request API Reference","text":"<p>This page documents the HTTPRequest class used in route handlers.</p>"},{"location":"api-reference/request/#httprequest-class","title":"HTTPRequest Class","text":""},{"location":"api-reference/request/#api_lambda.request.HTTPRequest","title":"<code>api_lambda.request.HTTPRequest</code>","text":"Source code in <code>api_lambda/request.py</code> <pre><code>class HTTPRequest:\n    body: Dict[str, Any]\n    path: Dict[str, str]\n    query: Dict[str, str]\n    headers: Dict[str, str]\n    context: Dict[str, Any]\n    method: Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]\n    def __init__(self, \n                 body: Dict[str, Any] = {}, \n                 path: Dict[str, str] = {}, \n                 query: Dict[str, str] = {},\n                 headers: Dict[str, str] = {}, \n                 context: Dict[str, Any] = {},\n                 method: Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"] = \"GET\"):\n        \"\"\"\n        Represents an HTTP request structure with common request data fields.\n\n        Args:\n            body (Dict[str, Any]): Parsed JSON body of the request, defaults to an empty dictionary.\n            path (Dict[str, str]): Path parameters extracted from the URL.\n            query (Dict[str, str]): Query parameters from the URL.\n            headers (Dict[str, str]): HTTP headers from the request.\n            context (Dict[str, Any]): Authorization or additional context from the request.\n        \"\"\"\n        self.body = body or {}\n        self.path = path or {}\n        self.query = query or {}\n        self.headers = headers or {}\n        self.context = context or {}\n        self.method = method\n\n    def __repr__(self) -&gt; str:\n        return f\"HTTPRequest(body={self.body}, path={self.path}, query={self.query}, headers={self.headers}, context={self.context}, method={self.method})\"\n</code></pre>"},{"location":"api-reference/request/#api_lambda.request.HTTPRequest.__init__","title":"<code>__init__(body={}, path={}, query={}, headers={}, context={}, method='GET')</code>","text":"<p>Represents an HTTP request structure with common request data fields.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Dict[str, Any]</code> <p>Parsed JSON body of the request, defaults to an empty dictionary.</p> <code>{}</code> <code>path</code> <code>Dict[str, str]</code> <p>Path parameters extracted from the URL.</p> <code>{}</code> <code>query</code> <code>Dict[str, str]</code> <p>Query parameters from the URL.</p> <code>{}</code> <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers from the request.</p> <code>{}</code> <code>context</code> <code>Dict[str, Any]</code> <p>Authorization or additional context from the request.</p> <code>{}</code> Source code in <code>api_lambda/request.py</code> <pre><code>def __init__(self, \n             body: Dict[str, Any] = {}, \n             path: Dict[str, str] = {}, \n             query: Dict[str, str] = {},\n             headers: Dict[str, str] = {}, \n             context: Dict[str, Any] = {},\n             method: Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"] = \"GET\"):\n    \"\"\"\n    Represents an HTTP request structure with common request data fields.\n\n    Args:\n        body (Dict[str, Any]): Parsed JSON body of the request, defaults to an empty dictionary.\n        path (Dict[str, str]): Path parameters extracted from the URL.\n        query (Dict[str, str]): Query parameters from the URL.\n        headers (Dict[str, str]): HTTP headers from the request.\n        context (Dict[str, Any]): Authorization or additional context from the request.\n    \"\"\"\n    self.body = body or {}\n    self.path = path or {}\n    self.query = query or {}\n    self.headers = headers or {}\n    self.context = context or {}\n    self.method = method\n</code></pre>"},{"location":"api-reference/response/","title":"Response API Reference","text":"<p>This page documents the response handling functionality.</p>"},{"location":"api-reference/response/#functions","title":"Functions","text":""},{"location":"api-reference/response/#api_lambda.response.create_response","title":"<code>api_lambda.response.create_response(status_code, body, cors=False, cors_origin='*')</code>","text":"<p>Formats the response for AWS API Gateway, with optional CORS support.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code (e.g., 200, 404).</p> required <code>body</code> <code>Any</code> <p>JSON-serializable response body.</p> required <code>cors</code> <code>bool</code> <p>Boolean flag to enable or disable CORS headers. Default is False.</p> <code>False</code> <code>cors_origin</code> <code>str</code> <p>Allowed CORS origin if CORS is enabled. Default is '*' (allowing all origins).</p> <code>'*'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A formatted response dictionary compatible with AWS API Gateway,              including CORS headers if specified.</p> Example <p>response = create_response(200, {\"message\": \"Success\"}, cors=True, cors_origin=\"https://example.com\") response[\"statusCode\"] 200 headers = response[\"headers\"] headers[\"Access-Control-Allow-Origin\"]` 'https://example.com'</p> Source code in <code>api_lambda/response.py</code> <pre><code>def create_response(status_code: int, body: Any, cors: bool = False, cors_origin: str = \"*\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Formats the response for AWS API Gateway, with optional CORS support.\n\n    Args:\n        status_code (int): HTTP status code (e.g., 200, 404).\n        body (Any): JSON-serializable response body.\n        cors (bool): Boolean flag to enable or disable CORS headers. Default is False.\n        cors_origin (str): Allowed CORS origin if CORS is enabled. Default is '*' (allowing all origins).\n\n    Returns:\n        Dict[str, Any]: A formatted response dictionary compatible with AWS API Gateway, \n                        including CORS headers if specified.\n\n    Example:\n        &gt;&gt;&gt; response = create_response(200, {\"message\": \"Success\"}, cors=True, cors_origin=\"https://example.com\")\n        &gt;&gt;&gt; response[\"statusCode\"]\n        200\n        &gt;&gt;&gt; headers = response[\"headers\"]\n        &gt;&gt;&gt; headers[\"Access-Control-Allow-Origin\"]`\n        'https://example.com'\n    \"\"\"\n    # Base headers for JSON response\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    if cors:\n        # Add CORS headers only if `cors=True`\n        headers.update({\n            \"Access-Control-Allow-Origin\": cors_origin,\n            \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type\"\n        })\n\n    return {\n        \"statusCode\": status_code,\n        \"body\": dumps(body),\n        \"headers\": headers\n    }\n</code></pre>"},{"location":"api-reference/response/#types","title":"Types","text":""},{"location":"api-reference/response/#api_lambda.response.ResponseData","title":"<code>api_lambda.response.ResponseData = Tuple[Dict[str, Any], int]</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/router/","title":"Router API Reference","text":"<p>This page documents the core routing functionality of API Lambda Router.</p>"},{"location":"api-reference/router/#functions","title":"Functions","text":""},{"location":"api-reference/router/#api_lambda.router.route","title":"<code>api_lambda.router.route(path, methods='GET')</code>","text":"<p>Decorator to register routes in the ROUTES dictionary. Supports both single method and multiple methods.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The endpoint path (e.g., '/docs', '/docs/', '/docs/{id}').        Supports both Flask-style  and API Gateway-style {param}. required <code>methods</code> <code>Union[HTTPMethod, List[HTTPMethod]]</code> <p>HTTP method(s) (e.g., 'GET', ['GET', 'POST']).</p> <code>'GET'</code> <p>Returns:</p> Type Description <code>Callable[[RouteHandler], RouteHandler]</code> <p>Callable[[RouteHandler], RouteHandler]: The decorator function that registers the route.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @route(\"/docs\", methods=\"POST\")\n... def create_document(request: HTTPRequest) -&gt; ResponseData:\n...     return {\"message\": \"Document created\"}, 201\n</code></pre> <pre><code>&gt;&gt;&gt; @route(\"/docs/&lt;id&gt;\", methods=[\"GET\", \"PUT\"])\n... def handle_document(request: HTTPRequest) -&gt; Dict[str, Any]:\n...     doc_id = request.path[\"id\"]\n...     return {\"id\": doc_id}\n</code></pre> Source code in <code>api_lambda/router.py</code> <pre><code>def route(\n    path: str, \n    methods: Union[HTTPMethod, List[HTTPMethod]] = \"GET\"\n) -&gt; Callable[[RouteHandler], RouteHandler]:\n    \"\"\"\n    Decorator to register routes in the ROUTES dictionary.\n    Supports both single method and multiple methods.\n\n    Args:\n        path (str): The endpoint path (e.g., '/docs', '/docs/&lt;id&gt;', '/docs/{id}').\n                   Supports both Flask-style &lt;param&gt; and API Gateway-style {param}.\n        methods (Union[HTTPMethod, List[HTTPMethod]]): HTTP method(s) (e.g., 'GET', ['GET', 'POST']).\n\n    Returns:\n        Callable[[RouteHandler], RouteHandler]: The decorator function that registers the route.\n\n    Examples:\n        &gt;&gt;&gt; @route(\"/docs\", methods=\"POST\")\n        ... def create_document(request: HTTPRequest) -&gt; ResponseData:\n        ...     return {\"message\": \"Document created\"}, 201\n\n        &gt;&gt;&gt; @route(\"/docs/&lt;id&gt;\", methods=[\"GET\", \"PUT\"])\n        ... def handle_document(request: HTTPRequest) -&gt; Dict[str, Any]:\n        ...     doc_id = request.path[\"id\"]\n        ...     return {\"id\": doc_id}\n    \"\"\"\n    def decorator(func: RouteHandler) -&gt; RouteHandler:\n        # Normalize path to use {param} format\n        normalized_path = normalize_path(path)\n\n        # Handle both single method and list of methods\n        method_list = [methods] if isinstance(methods, str) else methods\n\n        # Register each method\n        for method in method_list:\n            ROUTES[(normalized_path, method)] = func\n        return func\n    return decorator\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.lambda_handler","title":"<code>api_lambda.router.lambda_handler(event, context, cors=False, cors_origin='*', debug=False)</code>","text":"<p>Main handler to route requests based on path and method, with optional CORS support. Supports both API Gateway direct integration and proxy integration.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Dict[str, Any]</code> <p>AWS Lambda event containing request details.</p> required <code>context</code> <code>Any</code> <p>AWS Lambda context object.</p> required <code>cors</code> <code>bool</code> <p>Boolean flag to enable/disable CORS headers globally.</p> <code>False</code> <code>cors_origin</code> <code>str</code> <p>Allowed CORS origin if CORS is enabled (default is \"*\").</p> <code>'*'</code> <code>debug</code> <code>bool</code> <p>Include stack trace in error responses (default: False).</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A formatted response dictionary for AWS API Gateway, with optional CORS headers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @route(\"/hello\", methods=\"GET\")\n... def hello(request: HTTPRequest) -&gt; Dict[str, str]:\n...     return {\"message\": \"Hello, world!\"}\n</code></pre> <pre><code>&gt;&gt;&gt; def handler(event: Dict[str, Any], context: Any) -&gt; Dict[str, Any]:\n...     return lambda_handler(event, context, cors=True, debug=True)\n</code></pre> Source code in <code>api_lambda/router.py</code> <pre><code>def lambda_handler(\n    event: Dict[str, Any], \n    context: Any, \n    cors: bool = False, \n    cors_origin: str = \"*\",\n    debug: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Main handler to route requests based on path and method, with optional CORS support.\n    Supports both API Gateway direct integration and proxy integration.\n\n    Args:\n        event (Dict[str, Any]): AWS Lambda event containing request details.\n        context (Any): AWS Lambda context object.\n        cors (bool): Boolean flag to enable/disable CORS headers globally.\n        cors_origin (str): Allowed CORS origin if CORS is enabled (default is \"*\").\n        debug (bool): Include stack trace in error responses (default: False).\n\n    Returns:\n        Dict[str, Any]: A formatted response dictionary for AWS API Gateway, with optional CORS headers.\n\n    Examples:\n        &gt;&gt;&gt; @route(\"/hello\", methods=\"GET\")\n        ... def hello(request: HTTPRequest) -&gt; Dict[str, str]:\n        ...     return {\"message\": \"Hello, world!\"}\n\n        &gt;&gt;&gt; def handler(event: Dict[str, Any], context: Any) -&gt; Dict[str, Any]:\n        ...     return lambda_handler(event, context, cors=True, debug=True)\n    \"\"\"\n    # Extract HTTP method and path from event\n    http_method_raw: Any = event.get(\"httpMethod\") or event.get(\"requestContext\", {}).get(\"http\", {}).get(\"method\")\n    http_method: Optional[str] = http_method_raw if isinstance(http_method_raw, str) else None\n    path: str = extract_path_from_event(event)\n\n    # Handle preflight OPTIONS request for CORS\n    if http_method == \"OPTIONS\":\n        return create_response(200, {}, cors=cors, cors_origin=cors_origin)\n\n    # Ensure we have a valid HTTP method\n    if not http_method:\n        error_response = _error_response_factory(400, \"Missing HTTP method\", \"BAD_REQUEST\")\n        return create_response(400, error_response, cors=cors, cors_origin=cors_origin)\n\n    # Find matching route\n    handler, path_params = find_matching_route(path, http_method)\n\n    if handler:\n        # Safely parse JSON body with error handling\n        body_str_raw: Any = event.get(\"body\", \"{}\") or \"{}\"\n        body_str: str = body_str_raw if isinstance(body_str_raw, str) else \"{}\"\n        try:\n            parsed_body: Dict[str, Any] = loads(body_str)\n        except JSONDecodeError:\n            parsed_body = {}\n\n        # Create Request object with extracted data\n        request_data = HTTPRequest(\n            body=parsed_body,\n            path=path_params,\n            query=event.get(\"queryStringParameters\") or {},\n            headers=event.get(\"headers\") or {},\n            context=event.get(\"requestContext\", {}).get(\"authorizer\") or {},\n            method=cast(HTTPMethod, http_method)\n        )\n\n        try:\n            # Call the handler function with the Request object\n            result: Union[ResponseData, Dict[str, Any]] = handler(request_data)\n\n            # Handle different return types from handlers\n            if isinstance(result, tuple) and len(result) == 2:\n                # ResponseData is (status_code, body) format\n                response_body, status_code = result\n            else:\n                response_body, status_code = result, 200\n\n            return create_response(status_code, response_body, cors=cors, cors_origin=cors_origin)\n\n        except Exception as e:\n            # Capture the full traceback\n            exc_type, exc_value, exc_traceback = sys.exc_info()\n            traceback_details = traceback.format_exception(exc_type, exc_value, exc_traceback)\n            traceback_string = ''.join(traceback_details)\n\n            # Log the full traceback\n            print(\"Error processing request:\", e)\n            print(\"Traceback:\", traceback_string)\n\n            # Create error response\n            error_response = _error_response_factory(500, \"Internal Server Error\", \"INTERNAL_SERVER_ERROR\")\n\n            # Add traceback to response if debug mode is enabled\n            if debug:\n                error_response[\"traceback\"] = traceback_string\n\n            return create_response(500, error_response, cors=cors, cors_origin=cors_origin)\n\n    # No matching route found\n    error_response = _error_response_factory(404, \"Resource not found\", \"NOT_FOUND\")\n    return create_response(404, error_response, cors=cors, cors_origin=cors_origin)\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.api_handler","title":"<code>api_lambda.router.api_handler(event, context, cors_enabled=True, cors_origin='*', debug_mode=False, custom_error_factory=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event</code> <code>Dict[str, Any]</code> <p>AWS Lambda event</p> required <code>context</code> <code>Any</code> <p>AWS Lambda context</p> required <code>cors_enabled</code> <code>bool</code> <p>Enable CORS headers (default: True)</p> <code>True</code> <code>cors_origin</code> <code>str</code> <p>CORS origin (default: \"*\")</p> <code>'*'</code> <code>debug_mode</code> <code>bool</code> <p>Include debug info in errors (default: False)</p> <code>False</code> <code>custom_error_factory</code> <code>Optional[Callable[[int, str, str], Dict[str, Any]]]</code> <p>Custom error response factory</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: API Gateway response</p> Example <p>def custom_errors(status: int, msg: str, code: str) -&gt; Dict[str, Any]: ...     return {\"success\": False, \"error\": {\"message\": msg, \"code\": code}}</p> <p>def handler(event, context): ...     return api_handler(event, context,  ...                       debug_mode=True,  ...                       custom_error_factory=custom_errors)</p> Source code in <code>api_lambda/router.py</code> <pre><code>def api_handler(\n    event: Dict[str, Any], \n    context: Any,\n    cors_enabled: bool = True,\n    cors_origin: str = \"*\",\n    debug_mode: bool = False,\n    custom_error_factory: Optional[Callable[[int, str, str], Dict[str, Any]]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"    \n    Args:\n        event (Dict[str, Any]): AWS Lambda event\n        context (Any): AWS Lambda context\n        cors_enabled (bool): Enable CORS headers (default: True)\n        cors_origin (str): CORS origin (default: \"*\")\n        debug_mode (bool): Include debug info in errors (default: False)\n        custom_error_factory: Custom error response factory\n\n    Returns:\n        Dict[str, Any]: API Gateway response\n\n    Example:\n        &gt;&gt;&gt; def custom_errors(status: int, msg: str, code: str) -&gt; Dict[str, Any]:\n        ...     return {\"success\": False, \"error\": {\"message\": msg, \"code\": code}}\n\n        &gt;&gt;&gt; def handler(event, context):\n        ...     return api_handler(event, context, \n        ...                       debug_mode=True, \n        ...                       custom_error_factory=custom_errors)\n    \"\"\"\n    # Set custom error factory if provided\n    if custom_error_factory:\n        original_factory = _error_response_factory\n        set_error_response_factory(custom_error_factory)\n\n        try:\n            return lambda_handler(event, context, cors=cors_enabled, cors_origin=cors_origin, debug=debug_mode)\n        finally:\n            # Restore original factory\n            set_error_response_factory(original_factory)\n    else:\n        return lambda_handler(event, context, cors=cors_enabled, cors_origin=cors_origin, debug=debug_mode)\n</code></pre>"},{"location":"api-reference/router/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/router/#api_lambda.router.normalize_path","title":"<code>api_lambda.router.normalize_path(path)</code>","text":"<p>Normalize path to use {param} format consistently. Converts Flask-style  to API Gateway-style {param}.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Original path with either  or {param} format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Normalized path with {param} format</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; normalize_path(\"/users/&lt;id&gt;/posts/&lt;post_id&gt;\")\n'/users/{id}/posts/{post_id}'\n&gt;&gt;&gt; normalize_path(\"/users/{id}/posts/{post_id}\")\n'/users/{id}/posts/{post_id}'\n</code></pre> Source code in <code>api_lambda/router.py</code> <pre><code>def normalize_path(path: str) -&gt; str:\n    \"\"\"\n    Normalize path to use {param} format consistently.\n    Converts Flask-style &lt;param&gt; to API Gateway-style {param}.\n\n    Args:\n        path (str): Original path with either &lt;param&gt; or {param} format\n\n    Returns:\n        str: Normalized path with {param} format\n\n    Examples:\n        &gt;&gt;&gt; normalize_path(\"/users/&lt;id&gt;/posts/&lt;post_id&gt;\")\n        '/users/{id}/posts/{post_id}'\n        &gt;&gt;&gt; normalize_path(\"/users/{id}/posts/{post_id}\")\n        '/users/{id}/posts/{post_id}'\n    \"\"\"\n    return re.sub(r'&lt;([^&gt;]+)&gt;', r'{\\1}', path)\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.match_path","title":"<code>api_lambda.router.match_path(route_path, actual_path)</code>","text":"<p>Matches dynamic paths and extracts path parameters. Supports both exact matches and parameterized paths.</p> <p>Parameters:</p> Name Type Description Default <code>route_path</code> <code>str</code> <p>Route template path (e.g., '/docs/{id}').</p> required <code>actual_path</code> <code>str</code> <p>Incoming request path.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, Dict[str, str]]</code> <p>Tuple[bool, Dict[str, str]]: Tuple where the first element indicates if paths match                          and the second element contains extracted parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_path('/docs/{id}', '/docs/123')\n(True, {'id': '123'})\n&gt;&gt;&gt; match_path('/users/{user_id}/posts/{post_id}', '/users/456/posts/789')\n(True, {'user_id': '456', 'post_id': '789'})\n</code></pre> Source code in <code>api_lambda/router.py</code> <pre><code>def match_path(route_path: str, actual_path: str) -&gt; Tuple[bool, Dict[str, str]]:\n    \"\"\"\n    Matches dynamic paths and extracts path parameters.\n    Supports both exact matches and parameterized paths.\n\n    Args:\n        route_path (str): Route template path (e.g., '/docs/{id}').\n        actual_path (str): Incoming request path.\n\n    Returns:\n        Tuple[bool, Dict[str, str]]: Tuple where the first element indicates if paths match\n                                     and the second element contains extracted parameters.\n\n    Examples:\n        &gt;&gt;&gt; match_path('/docs/{id}', '/docs/123')\n        (True, {'id': '123'})\n        &gt;&gt;&gt; match_path('/users/{user_id}/posts/{post_id}', '/users/456/posts/789')\n        (True, {'user_id': '456', 'post_id': '789'})\n    \"\"\"\n    # Handle exact match first\n    if route_path == actual_path:\n        return True, {}\n\n    # Strip leading/trailing slashes and split\n    route_parts = [part for part in route_path.strip(\"/\").split(\"/\") if part]\n    path_parts = [part for part in actual_path.strip(\"/\").split(\"/\") if part]\n\n    # Must have same number of parts\n    if len(route_parts) != len(path_parts):\n        return False, {}\n\n    path_params: Dict[str, str] = {}\n    for route_part, path_part in zip(route_parts, path_parts):\n        if route_part.startswith(\"{\") and route_part.endswith(\"}\"):\n            # Extract parameter name\n            param_name = route_part[1:-1]\n            path_params[param_name] = path_part\n        elif route_part != path_part:\n            # Non-parameterized parts must match exactly\n            return False, {}\n\n    return True, path_params\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.find_matching_route","title":"<code>api_lambda.router.find_matching_route(path, method)</code>","text":"<p>Find a matching route handler for the given path and method.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Request path</p> required <code>method</code> <code>str</code> <p>HTTP method</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[RouteHandler], Dict[str, str]]</code> <p>Tuple[Optional[RouteHandler], Dict[str, str]]: Handler and extracted path parameters</p> Source code in <code>api_lambda/router.py</code> <pre><code>def find_matching_route(path: str, method: str) -&gt; Tuple[Optional[RouteHandler], Dict[str, str]]:\n    \"\"\"\n    Find a matching route handler for the given path and method.\n\n    Args:\n        path (str): Request path\n        method (str): HTTP method\n\n    Returns:\n        Tuple[Optional[RouteHandler], Dict[str, str]]: Handler and extracted path parameters\n    \"\"\"\n    # First try exact match\n    exact_key = (path, method)\n    if exact_key in ROUTES:\n        return ROUTES[exact_key], {}\n\n    # Then try pattern matching\n    for (route_path, route_method), handler in ROUTES.items():\n        if route_method == method:\n            match, path_params = match_path(route_path, path)\n            if match:\n                return handler, path_params\n\n    return None, {}\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.extract_path_from_event","title":"<code>api_lambda.router.extract_path_from_event(event)</code>","text":"<p>Extract the actual path from the Lambda event. Handles both API Gateway direct integration and proxy integration.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Dict[str, Any]</code> <p>AWS Lambda event</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted path</p> Source code in <code>api_lambda/router.py</code> <pre><code>def extract_path_from_event(event: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Extract the actual path from the Lambda event.\n    Handles both API Gateway direct integration and proxy integration.\n\n    Args:\n        event (Dict[str, Any]): AWS Lambda event\n\n    Returns:\n        str: Extracted path\n    \"\"\"\n    # Try to get path from different event structures\n    path: Any = event.get(\"path\")\n    if path and isinstance(path, str):\n        return str(path)\n\n    # Handle proxy integration where path might be in pathParameters or rawPath\n    raw_path: Any = event.get(\"rawPath\")\n    if raw_path and isinstance(raw_path, str):\n        return str(raw_path)\n\n    # Handle case where we need to construct path from pathParameters\n    path_parameters: Dict[str, Any] = event.get(\"pathParameters\") or {}\n    if \"proxy\" in path_parameters:\n        proxy_value: Any = path_parameters[\"proxy\"]\n        if isinstance(proxy_value, str):\n            return f\"/{proxy_value}\"\n\n    # Fallback to root if no path found\n    return \"/\"\n</code></pre>"},{"location":"api-reference/router/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/router/#api_lambda.router.set_error_response_factory","title":"<code>api_lambda.router.set_error_response_factory(factory)</code>","text":"<p>Set a custom error response factory.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>Callable[[int, str, str], Dict[str, Any]]</code> <p>Function that takes (status_code, message, error_code) and returns error dict</p> required Source code in <code>api_lambda/router.py</code> <pre><code>def set_error_response_factory(factory: Callable[[int, str, str], Dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Set a custom error response factory.\n\n    Args:\n        factory: Function that takes (status_code, message, error_code) and returns error dict\n    \"\"\"\n    global _error_response_factory\n    _error_response_factory = factory\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.default_error_response","title":"<code>api_lambda.router.default_error_response(status_code, message, error_code)</code>","text":"<p>Default error response factory.</p> Source code in <code>api_lambda/router.py</code> <pre><code>def default_error_response(status_code: int, message: str, error_code: str) -&gt; Dict[str, Any]:\n    \"\"\"Default error response factory.\"\"\"\n    return {\n        \"error\": True,\n        \"message\": message,\n        \"code\": error_code\n    }\n</code></pre>"},{"location":"api-reference/router/#types-and-protocols","title":"Types and Protocols","text":""},{"location":"api-reference/router/#api_lambda.router.RouteHandler","title":"<code>api_lambda.router.RouteHandler</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>api_lambda/router.py</code> <pre><code>class RouteHandler(Protocol):\n    def __call__(self, request: HTTPRequest) -&gt; Union[ResponseData, Dict[str, Any], Any]:\n        \"\"\"Route handler function signature.\"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.RouteHandler.__call__","title":"<code>__call__(request)</code>","text":"<p>Route handler function signature.</p> Source code in <code>api_lambda/router.py</code> <pre><code>def __call__(self, request: HTTPRequest) -&gt; Union[ResponseData, Dict[str, Any], Any]:\n    \"\"\"Route handler function signature.\"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/router/#api_lambda.router.HTTPMethod","title":"<code>api_lambda.router.HTTPMethod = Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD']</code>  <code>module-attribute</code>","text":""},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>Learn the core concepts and features of API Lambda Router.</p>"},{"location":"user-guide/basic-usage/#route-definition","title":"Route Definition","text":""},{"location":"user-guide/basic-usage/#basic-routes","title":"Basic Routes","text":"<p>Use the <code>@route()</code> decorator to define endpoints:</p> <pre><code>from api_lambda import route, HTTPRequest\n\n@route(\"/health\", methods=\"GET\")\ndef health_check(request: HTTPRequest):\n    return {\"status\": \"healthy\", \"timestamp\": \"2024-01-01T00:00:00Z\"}\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-http-methods","title":"Multiple HTTP Methods","text":"<p>A single function can handle multiple HTTP methods:</p> <pre><code>@route(\"/items\", methods=[\"GET\", \"POST\"])\ndef handle_items(request: HTTPRequest):\n    if request.method == 'POST':\n        # Create new item\n        return {\"created\": request.body, \"id\": \"123\"}, 201\n    elif request.method == 'GET':\n        return {\"items\": [\"item1\", \"item2\", \"item3\"]}\n</code></pre>"},{"location":"user-guide/basic-usage/#path-parameters","title":"Path Parameters","text":"<p>Extract dynamic values from URLs:</p> <pre><code># API Gateway style {param}\n@route(\"/users/{user_id}\", methods=\"GET\")\ndef get_user(request: HTTPRequest):\n    user_id = request.path[\"user_id\"]\n    return {\"user_id\": user_id, \"name\": f\"User {user_id}\"}\n\n# Flask style &lt;param&gt; (automatically converted)\n@route(\"/posts/&lt;post_id&gt;/comments/&lt;comment_id&gt;\", methods=\"GET\")\ndef get_comment(request: HTTPRequest):\n    return {\n        \"post_id\": request.path[\"post_id\"],\n        \"comment_id\": request.path[\"comment_id\"]\n    }\n</code></pre>"},{"location":"user-guide/basic-usage/#request-object","title":"Request Object","text":"<p>The <code>HTTPRequest</code> object provides structured access to request data:</p> <pre><code>def my_handler(request: HTTPRequest):\n    # Request body (parsed JSON)\n    body_data = request.body\n    name = body_data.get(\"name\", \"Unknown\")\n\n    # Path parameters\n    user_id = request.path.get(\"user_id\")\n\n    # Query parameters\n    limit = request.query.get(\"limit\", \"10\")\n\n    # HTTP headers\n    content_type = request.headers.get(\"Content-Type\")\n\n    # Authorization context (from API Gateway)\n    user_context = request.context.get(\"user\")\n\n    # HTTP method\n    method = request.method\n\n    return {\n        \"method\": method,\n        \"user_id\": user_id,\n        \"name\": name,\n        \"limit\": limit\n    }\n</code></pre>"},{"location":"user-guide/basic-usage/#request-properties","title":"Request Properties","text":"Property Type Description <code>body</code> <code>Dict[str, Any]</code> Parsed JSON request body <code>path</code> <code>Dict[str, str]</code> URL path parameters <code>query</code> <code>Dict[str, str]</code> Query string parameters <code>headers</code> <code>Dict[str, str]</code> HTTP headers <code>context</code> <code>Dict[str, Any]</code> Authorization context <code>method</code> <code>str</code> HTTP method (GET, POST, etc.)"},{"location":"user-guide/basic-usage/#response-handling","title":"Response Handling","text":""},{"location":"user-guide/basic-usage/#simple-responses","title":"Simple Responses","text":"<p>Return a dictionary for 200 OK responses:</p> <pre><code>@route(\"/simple\", methods=\"GET\")\ndef simple_response(request: HTTPRequest):\n    return {\"message\": \"Success\", \"data\": [1, 2, 3]}\n</code></pre>"},{"location":"user-guide/basic-usage/#custom-status-codes","title":"Custom Status Codes","text":"<p>Return a tuple with <code>(body, status_code)</code>:</p> <pre><code>@route(\"/users\", methods=\"POST\")\ndef create_user(request: HTTPRequest):\n    # Validate request\n    if not request.body.get(\"name\"):\n        return {\"error\": \"Name is required\"}, 400\n\n    # Create user\n    user = {\"id\": \"123\", \"name\": request.body[\"name\"]}\n    return user, 201\n\n@route(\"/users/{user_id}\", methods=\"DELETE\")\ndef delete_user(request: HTTPRequest):\n    user_id = request.path[\"user_id\"]\n    # Delete logic here...\n    return {\"message\": f\"User {user_id} deleted\"}, 204\n</code></pre>"},{"location":"user-guide/basic-usage/#cors-support","title":"CORS Support","text":"<p>Enable CORS for web browser requests:</p> <pre><code>def lambda_handler(event, context):\n    return api_handler(\n        event, \n        context,\n        cors_enabled=True,           # Enable CORS\n        cors_origin=\"*\"              # Allow all origins (or specify domain)\n    )\n</code></pre> <p>For production, specify allowed origins:</p> <pre><code>def lambda_handler(event, context):\n    return api_handler(\n        event, \n        context,\n        cors_enabled=True,\n        cors_origin=\"https://myapp.com\"  # Only allow your domain\n    )\n</code></pre>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/basic-usage/#automatic-error-responses","title":"Automatic Error Responses","text":"<p>The framework automatically handles common errors:</p> <pre><code># 404 Not Found - when no route matches\n# 500 Internal Server Error - when handler throws exception\n</code></pre>"},{"location":"user-guide/basic-usage/#custom-error-responses","title":"Custom Error Responses","text":"<p>Create custom error response formats:</p> <pre><code>def custom_error_factory(status_code: int, message: str, error_code: str):\n    return {\n        \"success\": False,\n        \"error\": {\n            \"message\": message,\n            \"code\": error_code,\n            \"status\": status_code,\n            \"timestamp\": \"2024-01-01T00:00:00Z\"\n        }\n    }\n\ndef lambda_handler(event, context):\n    return api_handler(\n        event, \n        context,\n        custom_error_factory=custom_error_factory\n    )\n</code></pre>"},{"location":"user-guide/basic-usage/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode for development:</p> <pre><code>def lambda_handler(event, context):\n    return api_handler(\n        event, \n        context,\n        debug_mode=True  # Includes stack traces in error responses\n    )\n</code></pre>"},{"location":"user-guide/basic-usage/#complete-example","title":"Complete Example","text":"<p>Here's a complete CRUD API example:</p> <pre><code>from api_lambda import route, api_handler, HTTPRequest\n\n# In-memory storage (use a database in production)\nusers = {\n    \"1\": {\"id\": \"1\", \"name\": \"John Doe\", \"email\": \"john@example.com\"},\n    \"2\": {\"id\": \"2\", \"name\": \"Jane Smith\", \"email\": \"jane@example.com\"}\n}\n\n@route(\"/users\", methods=\"GET\")\ndef list_users(request: HTTPRequest):\n    \"\"\"List all users.\"\"\"\n    return {\"users\": list(users.values())}\n\n@route(\"/users\", methods=\"POST\")\ndef create_user(request: HTTPRequest):\n    \"\"\"Create a new user.\"\"\"\n    if not request.body.get(\"name\") or not request.body.get(\"email\"):\n        return {\"error\": \"Name and email are required\"}, 400\n\n    user_id = str(len(users) + 1)\n    user = {\n        \"id\": user_id,\n        \"name\": request.body[\"name\"],\n        \"email\": request.body[\"email\"]\n    }\n    users[user_id] = user\n    return user, 201\n\n@route(\"/users/{user_id}\", methods=\"GET\")\ndef get_user(request: HTTPRequest):\n    \"\"\"Get a specific user.\"\"\"\n    user_id = request.path[\"user_id\"]\n    if user_id not in users:\n        return {\"error\": \"User not found\"}, 404\n    return users[user_id]\n\n@route(\"/users/{user_id}\", methods=\"PUT\")\ndef update_user(request: HTTPRequest):\n    \"\"\"Update a user.\"\"\"\n    user_id = request.path[\"user_id\"]\n    if user_id not in users:\n        return {\"error\": \"User not found\"}, 404\n\n    user = users[user_id]\n    user.update(request.body)\n    return user\n\n@route(\"/users/{user_id}\", methods=\"DELETE\")\ndef delete_user(request: HTTPRequest):\n    \"\"\"Delete a user.\"\"\"\n    user_id = request.path[\"user_id\"]\n    if user_id not in users:\n        return {\"error\": \"User not found\"}, 404\n\n    del users[user_id]\n    return {\"message\": \"User deleted successfully\"}\n\ndef lambda_handler(event, context):\n    return api_handler(event, context, cors_enabled=True, debug_mode=True)\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will help you create your first API using API Lambda Router.</p>"},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>AWS account (for deployment)</li> <li>Basic understanding of AWS Lambda and API Gateway</li> </ul>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":"<p>Install the package from PyPI:</p> <pre><code>pip install api-lambda-router\n</code></pre> <p>or download the source code and add to your project manually.</p>"},{"location":"user-guide/getting-started/#creating-your-first-api","title":"Creating Your First API","text":""},{"location":"user-guide/getting-started/#step-1-create-a-lambda-function","title":"Step 1: Create a Lambda Function","text":"<p>Create a new file called <code>lambda_function.py</code>:</p> <pre><code>from api_lambda import route, api_handler, HTTPRequest\n\n@route(\"/hello\", methods=\"GET\")\ndef hello_world(request: HTTPRequest):\n    \"\"\"Simple hello world endpoint.\"\"\"\n    return {\"message\": \"Hello, World!\", \"status\": \"success\"}\n\n@route(\"/echo\", methods=\"POST\")\ndef echo_message(request: HTTPRequest):\n    \"\"\"Echo back the request body.\"\"\"\n    message = request.body.get(\"message\", \"No message provided\")\n    return {\"echo\": message}\n\n@route(\"/users/{user_id}\", methods=\"GET\")\ndef get_user(request: HTTPRequest):\n    \"\"\"Get user by ID from path parameter.\"\"\"\n    user_id = request.path[\"user_id\"]\n    return {\n        \"user_id\": user_id,\n        \"name\": f\"User {user_id}\",\n        \"email\": f\"user{user_id}@example.com\"\n    }\n\n# Lambda handler function\ndef lambda_handler(event, context):\n    return api_handler(\n        event, \n        context, \n        cors_enabled=True,  # Enable CORS for web requests\n        debug_mode=True     # Include stack traces in errors (disable in production)\n    )\n</code></pre>"},{"location":"user-guide/getting-started/#step-2-test-locally","title":"Step 2: Test Locally","text":"<p>You can test your routes locally by creating a mock event:</p> <pre><code># test_local.py\nfrom lambda_function import lambda_handler\n\ndef test_hello():\n    event = {\n        \"httpMethod\": \"GET\",\n        \"path\": \"/hello\",\n        \"body\": None,\n        \"queryStringParameters\": None,\n        \"headers\": {},\n        \"requestContext\": {}\n    }\n\n    response = lambda_handler(event, {})\n    print(f\"Status: {response['statusCode']}\")\n    print(f\"Body: {response['body']}\")\n\nif __name__ == \"__main__\":\n    test_hello()\n</code></pre> <p>Run the test:</p> <pre><code>python test_local.py\n</code></pre>"}]}